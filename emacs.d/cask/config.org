#+TITLE: Emacs Configuration
#+AUTHOR: Dmitri Akatov
#+Email: akatov@gmail.com

* Startup
** Header

This is to remind me in case I start editing [[file:config.el][config.el]] by mistake...

#+BEGIN_SRC emacs-lisp
;; config.el is autogenerated by org-babel-load-file from config.org ;;
;; -------------- do not edit this file directly ------------------- ;;
#+END_SRC

** Package
# #+BEGIN_SRC emacs-lisp
#   (require 'package)
#   (add-to-list 'package-archives
#                '("melpa" . "http://melpa.org/packages/") t)
#   (add-to-list 'package-archives
#                '("org" . "http://orgmode.org/elpa/") t)
#   (package-initialize)
# #+END_SRC

** Cask

I use cask to make upgrading packages easier.

# #+BEGIN_SRC ignore-me
# (require 'cask "~/.cask/cask.el")
# (cask-initialize)
# #+END_SRC

** Use-Package

use use-package to configure (and install) everything else

# #+BEGIN_SRC emacs-lisp
# (unless (package-installed-p 'use-package)
#   (package-refresh-contents)
#   (package-install 'use-package))
# (require 'use-package)
# (eval-when-compile
#   (require 'use-package))
# (require 'diminish)
# (require 'bind-key)
# #+END_SRC

* Global Config
** Path

In NextStep (OSX) window mode load the path settings from the shell

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :if (memq window-system '(mac ns))
    :ensure t
    :init
    (setq exec-path-from-shell-variables
     '("PATH"
       "MANPATH"
       "GOPATH"
       "MAVEN_OPTS"))
    (exec-path-from-shell-initialize))
#+END_SRC

** Defaults

Just answer `y` or `n`.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Custom-File

Keep custom settings in a [[file:custom.el][separate custom file]] instead of directly in [[file:init.el][init.el]].

#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file 'noerror)
#+END_SRC

Also, I should try to keep the custom file empty,
and instead put all the customizations in the next section.

** General Customizations
These are the customizations that may have lived in the custom file,
and don't have anything to do with any specific mode refered to
from use-package...
#+BEGIN_SRC emacs-lisp
  (ido-mode 'buffers)    ;; I only like ido-mode for switching buffers.
  (blink-cursor-mode t)  ;; turn blinking on
  (column-number-mode t) ;; show columns
  (setq mouse-wheel-progressive-speed nil)
  (setq mouse-wheel-scroll-amount
   '((nil . 1)
     ((control) . 3)
     ((shift) . 5)
     ((control shift) . 7)
     ((meta) . 9)
     ((meta control) . 11)
     ((meta shift) . 13)
     ((meta shift control) . 1.0)))
#+END_SRC

** Keybindings

Some global keybindings I like to use...

#+BEGIN_SRC emacs-lisp
(bind-keys ("M-g h" . windmove-left)
           ("M-g j" . windmove-down)
           ("M-g k" . windmove-up)
           ("M-g l" . windmove-right)
           ("M-g M-h" . windmove-left)
           ("M-g M-j" . windmove-down)
           ("M-g M-k" . windmove-up)
           ("M-g M-l" . windmove-right))
(bind-key "<s-return>" 'toggle-frame-fullscreen)
#+END_SRC

* Private Config

Some configuration settings I don't want the world to see.
I keep them in a separate private repo.

#+BEGIN_SRC emacs-lisp
(use-package f
  :ensure t)
(mapc (lambda (f) (load f)) (f-files "~/.emacs.d/private"))
#+END_SRC

* Theme

** Cyberpunk theme

#+BEGIN_SRC emacs-lisp
(use-package cyberpunk-theme
  :if (window-system)
  :ensure t
  :init
  (progn
    (load-theme 'cyberpunk t)
    (set-face-attribute `mode-line nil
                        :box nil)
    (set-face-attribute `mode-line-inactive nil
                        :box nil)))
#+END_SRC

** Solarized theme

#+BEGIN_SRC emacs-lisp
(use-package solarized-theme
  :defer 10
  :init
  (setq solarized-use-variable-pitch nil)
  :ensure t)
#+END_SRC

** Monokai theme

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package monokai-theme
    :if (window-system)
    :ensure t
    :init
    (setq monokai-use-variable-pitch nil))
#+end_src

** Waher theme

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package waher-theme
    :if (window-system)
    :ensure t
    :init
    (load-theme 'waher))
#+end_src

** Convenient theme functions

#+begin_src emacs-lisp
(defun switch-theme (theme)
  "Disables any currently active themes and loads THEME."
  ;; This interactive call is taken from `load-theme'
  (interactive
   (list
    (intern (completing-read "Load custom theme: "
                             (mapc 'symbol-name
                                   (custom-available-themes))))))
  (let ((enabled-themes custom-enabled-themes))
    (mapc #'disable-theme custom-enabled-themes)
    (load-theme theme t)))

(defun disable-active-themes ()
  "Disables any currently active themes listed in `custom-enabled-themes'."
  (interactive)
  (mapc #'disable-theme custom-enabled-themes))

(bind-key "s-<f12>" 'switch-theme)
(bind-key "s-<f11>" 'disable-active-themes)
#+end_src

* Org Mode

#+BEGIN_SRC emacs-lisp
(define-key global-map "\C-cl" 'org-store-link)
(define-key global-map "\C-ca" 'org-agenda)
(setq org-log-done t)
(setq org-use-speed-commands t)
#+END_SRC

** babel
#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (clojure . t)))

;; Use cider as the clojure execution backend
(setq org-babel-clojure-backend 'cider)

;; Let's have pretty source code blocks
(setq org-edit-src-content-indentation 0
      org-src-tab-acts-natively t
      org-src-fontify-natively t
      org-confirm-babel-evaluate nil)
#+END_SRC

** plus contrib                                               :hello:abc:def:
   :PROPERTIES:
   :Effort:   10
   :END:
   :LOGBOOK:
   CLOCK: [2016-03-25 Fri 02:09]--[2016-03-25 Fri 02:10] =>  0:01
   :END:

#+BEGIN_SRC comment emacs-lisp
(use-package org-plus-contrib
  :ensure t)
#+END_SRC

** Ox Reveal

#+BEGIN_SRC emacs-lisp
(use-package ox-reveal
  :ensure t)
#+END_SRC

* Package Config

** Ace-Jump

#+BEGIN_SRC emacs-lisp
(use-package ace-jump-mode
  :ensure t
  :bind (("C-;" . ace-jump-mode)
         ("C-c SPC" . ace-jump-mode)
         ("C-c C-SPC" . ace-jump-mode)))
#+END_SRC

** Subword

#+BEGIN_SRC emacs-lisp
(use-package subword-mode
  :init
  (add-hooks
   '(haskell-mode-hook
     coffee-mode-hook
     js2-mode-hook)
   '(subword-mode)))
#+END_SRC

** Paredit

#+BEGIN_SRC emacs-lisp
(use-package paredit
  :ensure t
    :init

    (autoload 'enable-paredit-mode "paredit"
      "Turn on pseudo-structural editing of Lisp code."
      t)

    (defvar electrify-return-match
      "[\]}\)\"]"
      "If this regexp matches the text after the cursor, do an \"electric\"
    return.")

    (defun electrify-return-if-match (arg)
      "If the text after the cursor matches `electrify-return-match' then
    open and indent an empty line between the cursor and the text.  Move the
    cursor to the new line."
      (interactive "P")
      (let ((case-fold-search nil))
        (if (looking-at electrify-return-match)
            (save-excursion (newline-and-indent)))
        (newline arg)
        (indent-according-to-mode)))

    (defun activate-electrify-return ()
      (local-set-key (kbd "RET") 'electrify-return-if-match))

    (defun activate-clojure-paredit-curly ()
      (define-key clojure-mode-map "{" 'paredit-open-curly)
      (define-key clojure-mode-map "}" 'paredit-close-curly))

    (defun setup-paredit-eldoc-commands ()
      (turn-on-eldoc-mode)
      (eldoc-add-command 'paredit-backward-delete
                         'paredit-close-round
                         'electrify-return-if-match))

    (add-hook 'clojure-mode-hook 'activate-clojure-paredit-curly)

    (add-hooks '(emacs-lisp-mode-hook)
               '(activate-electrify-return
                 setup-paredit-eldoc-commands))

  ;;; paredit doesn't do this automatically
    (add-hooks
     '(clojure-mode-hook
       emacs-lisp-mode-hook
       lisp-interaction-mode-hook
       lisp-mode-hook
       scheme-mode-hook)
     '(enable-paredit-mode))

  ;;; paredit for javascript

    (defun my-paredit-nonlisp ()
      "Turn on paredit mode for non-lisps."
      (interactive)
      (set (make-local-variable 'paredit-space-for-delimiter-predicates)
           '((lambda (endp delimiter) nil)))
      (paredit-mode 1))

    (defun activate-js2-paredit-curly ()
      (define-key js2-mode-map "{" 'paredit-open-curly)
      (define-key js2-mode-map "}" 'paredit-close-curly))

    (add-hook 'js2-mode-hook 'activate-js2-paredit-curly)

    (add-hooks
     '(js-mode-hook js2-mode-hook)
     '(my-paredit-nonlisp)))
#+END_SRC

** Handlebars Sgml Mode
#+BEGIN_SRC emacs-lisp
  (use-package handlebars-sgml-mode
    :ensure t)
#+END_SRC
** Less Css Mode
#+BEGIN_SRC emacs-lisp
  (use-package less-css-mode
    :ensure t)
#+END_SRC
** JSCS
#+BEGIN_SRC emacs-lisp
  ;; (use-package jscs
  ;;   :init
  ;;   (add-hook 'js-mode-hook #'jscs-indent-apply)
  ;;   (add-hook 'js2-mode-hook #'jscs-indent-apply)
  ;;   (add-hook 'json-mode-hook #'jscs-indent-apply))
#+END_SRC
** js2-mode
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
    (add-to-list 'auto-mode-alist '("\\.json\\'" . js2-mode)))
#+END_SRC
** markdown-mode
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode)))
#+END_SRC
** company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :init
    (global-company-mode))
#+END_SRC
** company-quickhelp
#+BEGIN_SRC emacs-lisp
  (use-package company-quickhelp
    :init
    (company-quickhelp-mode 1))
#+END_SRC
** js2-highlight-vars
#+BEGIN_SRC emacs-lisp
  ;; (use-package js2-highlight-vars
  ;;   :init
  ;;   (add-hook 'js2-mode-hook 'js2-highlight-vars-mode))
#+END_SRC
** yaml-mode
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :ensure t)
#+END_SRC
** neotree
#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :ensure t
    :init
    (bind-key [f8] 'neotree-toggle))
#+END_SRC
** cider
#+BEGIN_SRC emacs-lisp
(use-package cider
  :ensure t
  :init
  (setq nrepl-hide-special-buffers t
        cider-repl-pop-to-buffer-on-connect nil
        cider-popup-stacktraces nil
        cider-repl-popup-stacktraces t))
#+END_SRC
** magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :init
  (bind-key "C-x g" 'magit-status))
#+END_SRC
* Temp

These definitions are looking to be moved somewhere else.

#+BEGIN_SRC emacs-lisp
(use-package hl-line
  :config (set-face-background 'hl-line "#073642"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ac-emoji
  :init
  (set-fontset-font
   t 'symbol
   (font-spec :family "Apple Color Emoji") nil 'prepend)
  :config
  (add-hook 'git-commit-mode-hook 'ac-emoji-setup))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package company-emoji
  :init
  (defun --set-emoji-font (frame)
    "Adjust the font settings of FRAME so Emacs can display emoji properly."
    (if (eq system-type 'darwin)
        ;; For NS/Cocoa
        (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") frame 'prepend)
      ;; For Linux
      (set-fontset-font t 'symbol (font-spec :family "Symbola") frame 'prepend)))

  ;; For when Emacs is started in GUI mode:
  (--set-emoji-font nil)
  ;; Hook for when a frame is created with emacsclient
  ;; see https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Frames.html
  :config
  (add-to-list 'company-backends 'company-emoji)
  (add-hook 'after-make-frame-functions '--set-emoji-font)
  (setq company-emoji-insert-unicode nil))
#+END_SRC
